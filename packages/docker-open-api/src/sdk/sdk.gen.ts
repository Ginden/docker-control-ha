// This file is auto-generated by @hey-api/openapi-ts

import type { Options as ClientOptions, TDataShape, Client } from './client';
import type { ContainerListData, ContainerListResponses, ContainerListErrors, ContainerCreateData, ContainerCreateResponses, ContainerCreateErrors, ContainerInspectData, ContainerInspectResponses, ContainerInspectErrors, ContainerTopData, ContainerTopResponses, ContainerTopErrors, ContainerLogsData, ContainerLogsResponses, ContainerLogsErrors, ContainerChangesData, ContainerChangesResponses, ContainerChangesErrors, ContainerExportData, ContainerExportResponses, ContainerExportErrors, ContainerStatsData, ContainerStatsResponses, ContainerStatsErrors, ContainerResizeData, ContainerResizeResponses, ContainerResizeErrors, ContainerStartData, ContainerStartResponses, ContainerStartErrors, ContainerStopData, ContainerStopResponses, ContainerStopErrors, ContainerRestartData, ContainerRestartResponses, ContainerRestartErrors, ContainerKillData, ContainerKillResponses, ContainerKillErrors, ContainerUpdateData, ContainerUpdateResponses, ContainerUpdateErrors, ContainerRenameData, ContainerRenameResponses, ContainerRenameErrors, ContainerPauseData, ContainerPauseResponses, ContainerPauseErrors, ContainerUnpauseData, ContainerUnpauseResponses, ContainerUnpauseErrors, ContainerAttachData, ContainerAttachResponses, ContainerAttachErrors, ContainerAttachWebsocketData, ContainerAttachWebsocketResponses, ContainerAttachWebsocketErrors, ContainerWaitData, ContainerWaitResponses, ContainerWaitErrors, ContainerDeleteData, ContainerDeleteResponses, ContainerDeleteErrors, ContainerArchiveData, ContainerArchiveResponses, ContainerArchiveErrors, ContainerArchiveInfoData, ContainerArchiveInfoResponses, ContainerArchiveInfoErrors, PutContainerArchiveData, PutContainerArchiveResponses, PutContainerArchiveErrors, ContainerPruneData, ContainerPruneResponses, ContainerPruneErrors, ImageListData, ImageListResponses, ImageListErrors, ImageBuildData, ImageBuildResponses, ImageBuildErrors, BuildPruneData, BuildPruneResponses, BuildPruneErrors, ImageCreateData, ImageCreateResponses, ImageCreateErrors, ImageInspectData, ImageInspectResponses, ImageInspectErrors, ImageHistoryData, ImageHistoryResponses, ImageHistoryErrors, ImagePushData, ImagePushResponses, ImagePushErrors, ImageTagData, ImageTagResponses, ImageTagErrors, ImageDeleteData, ImageDeleteResponses, ImageDeleteErrors, ImageSearchData, ImageSearchResponses, ImageSearchErrors, ImagePruneData, ImagePruneResponses, ImagePruneErrors, SystemAuthData, SystemAuthResponses, SystemAuthErrors, SystemInfoData, SystemInfoResponses, SystemInfoErrors, SystemVersionData, SystemVersionResponses, SystemVersionErrors, SystemPingData, SystemPingResponses, SystemPingErrors, SystemPingHeadData, SystemPingHeadResponses, SystemPingHeadErrors, ImageCommitData, ImageCommitResponses, ImageCommitErrors, SystemEventsData, SystemEventsResponses, SystemEventsErrors, SystemDataUsageData, SystemDataUsageResponses, SystemDataUsageErrors, ImageGetData, ImageGetResponses, ImageGetErrors, ImageGetAllData, ImageGetAllResponses, ImageGetAllErrors, ImageLoadData, ImageLoadResponses, ImageLoadErrors, ContainerExecData, ContainerExecResponses, ContainerExecErrors, ExecStartData, ExecStartResponses, ExecStartErrors, ExecResizeData, ExecResizeResponses, ExecResizeErrors, ExecInspectData, ExecInspectResponses, ExecInspectErrors, VolumeListData, VolumeListResponses, VolumeListErrors, VolumeCreateData, VolumeCreateResponses, VolumeCreateErrors, VolumeDeleteData, VolumeDeleteResponses, VolumeDeleteErrors, VolumeInspectData, VolumeInspectResponses, VolumeInspectErrors, VolumeUpdateData, VolumeUpdateResponses, VolumeUpdateErrors, VolumePruneData, VolumePruneResponses, VolumePruneErrors, NetworkListData, NetworkListResponses, NetworkListErrors, NetworkDeleteData, NetworkDeleteResponses, NetworkDeleteErrors, NetworkInspectData, NetworkInspectResponses, NetworkInspectErrors, NetworkCreateData, NetworkCreateResponses, NetworkCreateErrors, NetworkConnectData, NetworkConnectResponses, NetworkConnectErrors, NetworkDisconnectData, NetworkDisconnectResponses, NetworkDisconnectErrors, NetworkPruneData, NetworkPruneResponses, NetworkPruneErrors, PluginListData, PluginListResponses, PluginListErrors, GetPluginPrivilegesData, GetPluginPrivilegesResponses, GetPluginPrivilegesErrors, PluginPullData, PluginPullResponses, PluginPullErrors, PluginInspectData, PluginInspectResponses, PluginInspectErrors, PluginDeleteData, PluginDeleteResponses, PluginDeleteErrors, PluginEnableData, PluginEnableResponses, PluginEnableErrors, PluginDisableData, PluginDisableResponses, PluginDisableErrors, PluginUpgradeData, PluginUpgradeResponses, PluginUpgradeErrors, PluginCreateData, PluginCreateResponses, PluginCreateErrors, PluginPushData, PluginPushResponses, PluginPushErrors, PluginSetData, PluginSetResponses, PluginSetErrors, NodeListData, NodeListResponses, NodeListErrors, NodeDeleteData, NodeDeleteResponses, NodeDeleteErrors, NodeInspectData, NodeInspectResponses, NodeInspectErrors, NodeUpdateData, NodeUpdateResponses, NodeUpdateErrors, SwarmInspectData, SwarmInspectResponses, SwarmInspectErrors, SwarmInitData, SwarmInitResponses, SwarmInitErrors, SwarmJoinData, SwarmJoinResponses, SwarmJoinErrors, SwarmLeaveData, SwarmLeaveResponses, SwarmLeaveErrors, SwarmUpdateData, SwarmUpdateResponses, SwarmUpdateErrors, SwarmUnlockkeyData, SwarmUnlockkeyResponses, SwarmUnlockkeyErrors, SwarmUnlockData, SwarmUnlockResponses, SwarmUnlockErrors, ServiceListData, ServiceListResponses, ServiceListErrors, ServiceCreateData, ServiceCreateResponses, ServiceCreateErrors, ServiceDeleteData, ServiceDeleteResponses, ServiceDeleteErrors, ServiceInspectData, ServiceInspectResponses, ServiceInspectErrors, ServiceUpdateData, ServiceUpdateResponses, ServiceUpdateErrors, ServiceLogsData, ServiceLogsResponses, ServiceLogsErrors, TaskListData, TaskListResponses, TaskListErrors, TaskInspectData, TaskInspectResponses, TaskInspectErrors, TaskLogsData, TaskLogsResponses, TaskLogsErrors, SecretListData, SecretListResponses, SecretListErrors, SecretCreateData, SecretCreateResponses, SecretCreateErrors, SecretDeleteData, SecretDeleteResponses, SecretDeleteErrors, SecretInspectData, SecretInspectResponses, SecretInspectErrors, SecretUpdateData, SecretUpdateResponses, SecretUpdateErrors, ConfigListData, ConfigListResponses, ConfigListErrors, ConfigCreateData, ConfigCreateResponses, ConfigCreateErrors, ConfigDeleteData, ConfigDeleteResponses, ConfigDeleteErrors, ConfigInspectData, ConfigInspectResponses, ConfigInspectErrors, ConfigUpdateData, ConfigUpdateResponses, ConfigUpdateErrors, DistributionInspectData, DistributionInspectResponses, DistributionInspectErrors, SessionData, SessionErrors } from './types.gen';
import { client as _heyApiClient } from './client.gen';

export type Options<TData extends TDataShape = TDataShape, ThrowOnError extends boolean = boolean> = ClientOptions<TData, ThrowOnError> & {
    /**
     * You can provide a client instance returned by `createClient()` instead of
     * individual options. This might be also useful if you want to implement a
     * custom client.
     */
    client?: Client;
    /**
     * You can pass arbitrary values through the `meta` object. This can be
     * used to access values that aren't defined as part of the SDK function.
     */
    meta?: Record<string, unknown>;
};

/**
 * List containers
 * Returns a list of containers. For details on the format, see the
 * [inspect endpoint](#operation/ContainerInspect).
 *
 * Note that it uses a different, smaller representation of a container
 * than inspecting a single container. For example, the list of linked
 * containers is not propagated .
 *
 */
export const containerList = <ThrowOnError extends boolean = false>(options?: Options<ContainerListData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<ContainerListResponses, ContainerListErrors, ThrowOnError>({
        responseType: 'json',
        url: '/containers/json',
        ...options
    });
};

/**
 * Create a container
 */
export const containerCreate = <ThrowOnError extends boolean = false>(options: Options<ContainerCreateData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<ContainerCreateResponses, ContainerCreateErrors, ThrowOnError>({
        responseType: 'json',
        url: '/containers/create',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Inspect a container
 * Return low-level information about a container.
 */
export const containerInspect = <ThrowOnError extends boolean = false>(options: Options<ContainerInspectData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<ContainerInspectResponses, ContainerInspectErrors, ThrowOnError>({
        responseType: 'json',
        url: '/containers/{id}/json',
        ...options
    });
};

/**
 * List processes running inside a container
 * On Unix systems, this is done by running the `ps` command. This endpoint
 * is not supported on Windows.
 *
 */
export const containerTop = <ThrowOnError extends boolean = false>(options: Options<ContainerTopData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<ContainerTopResponses, ContainerTopErrors, ThrowOnError>({
        responseType: 'json',
        url: '/containers/{id}/top',
        ...options
    });
};

/**
 * Get container logs
 * Get `stdout` and `stderr` logs from a container.
 *
 * Note: This endpoint works only for containers with the `json-file` or
 * `journald` logging driver.
 *
 */
export const containerLogs = <ThrowOnError extends boolean = false>(options: Options<ContainerLogsData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<ContainerLogsResponses, ContainerLogsErrors, ThrowOnError>({
        responseType: 'blob',
        url: '/containers/{id}/logs',
        ...options
    });
};

/**
 * Get changes on a container’s filesystem
 * Returns which files in a container's filesystem have been added, deleted,
 * or modified. The `Kind` of modification can be one of:
 *
 * - `0`: Modified ("C")
 * - `1`: Added ("A")
 * - `2`: Deleted ("D")
 *
 */
export const containerChanges = <ThrowOnError extends boolean = false>(options: Options<ContainerChangesData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<ContainerChangesResponses, ContainerChangesErrors, ThrowOnError>({
        responseType: 'json',
        url: '/containers/{id}/changes',
        ...options
    });
};

/**
 * Export a container
 * Export the contents of a container as a tarball.
 */
export const containerExport = <ThrowOnError extends boolean = false>(options: Options<ContainerExportData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<ContainerExportResponses, ContainerExportErrors, ThrowOnError>({
        responseType: 'blob',
        url: '/containers/{id}/export',
        ...options
    });
};

/**
 * Get container stats based on resource usage
 * This endpoint returns a live stream of a container’s resource usage
 * statistics.
 *
 * The `precpu_stats` is the CPU statistic of the *previous* read, and is
 * used to calculate the CPU usage percentage. It is not an exact copy
 * of the `cpu_stats` field.
 *
 * If either `precpu_stats.online_cpus` or `cpu_stats.online_cpus` is
 * nil then for compatibility with older daemons the length of the
 * corresponding `cpu_usage.percpu_usage` array should be used.
 *
 * On a cgroup v2 host, the following fields are not set
 * * `blkio_stats`: all fields other than `io_service_bytes_recursive`
 * * `cpu_stats`: `cpu_usage.percpu_usage`
 * * `memory_stats`: `max_usage` and `failcnt`
 * Also, `memory_stats.stats` fields are incompatible with cgroup v1.
 *
 * To calculate the values shown by the `stats` command of the docker cli tool
 * the following formulas can be used:
 * * used_memory = `memory_stats.usage - memory_stats.stats.cache`
 * * available_memory = `memory_stats.limit`
 * * Memory usage % = `(used_memory / available_memory) * 100.0`
 * * cpu_delta = `cpu_stats.cpu_usage.total_usage - precpu_stats.cpu_usage.total_usage`
 * * system_cpu_delta = `cpu_stats.system_cpu_usage - precpu_stats.system_cpu_usage`
 * * number_cpus = `length(cpu_stats.cpu_usage.percpu_usage)` or `cpu_stats.online_cpus`
 * * CPU usage % = `(cpu_delta / system_cpu_delta) * number_cpus * 100.0`
 *
 */
export const containerStats = <ThrowOnError extends boolean = false>(options: Options<ContainerStatsData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<ContainerStatsResponses, ContainerStatsErrors, ThrowOnError>({
        responseType: 'json',
        url: '/containers/{id}/stats',
        ...options
    });
};

/**
 * Resize a container TTY
 * Resize the TTY for a container.
 */
export const containerResize = <ThrowOnError extends boolean = false>(options: Options<ContainerResizeData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<ContainerResizeResponses, ContainerResizeErrors, ThrowOnError>({
        responseType: 'text',
        url: '/containers/{id}/resize',
        ...options
    });
};

/**
 * Start a container
 */
export const containerStart = <ThrowOnError extends boolean = false>(options: Options<ContainerStartData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<ContainerStartResponses, ContainerStartErrors, ThrowOnError>({
        responseType: 'json',
        url: '/containers/{id}/start',
        ...options
    });
};

/**
 * Stop a container
 */
export const containerStop = <ThrowOnError extends boolean = false>(options: Options<ContainerStopData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<ContainerStopResponses, ContainerStopErrors, ThrowOnError>({
        responseType: 'json',
        url: '/containers/{id}/stop',
        ...options
    });
};

/**
 * Restart a container
 */
export const containerRestart = <ThrowOnError extends boolean = false>(options: Options<ContainerRestartData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<ContainerRestartResponses, ContainerRestartErrors, ThrowOnError>({
        responseType: 'json',
        url: '/containers/{id}/restart',
        ...options
    });
};

/**
 * Kill a container
 * Send a POSIX signal to a container, defaulting to killing to the
 * container.
 *
 */
export const containerKill = <ThrowOnError extends boolean = false>(options: Options<ContainerKillData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<ContainerKillResponses, ContainerKillErrors, ThrowOnError>({
        responseType: 'json',
        url: '/containers/{id}/kill',
        ...options
    });
};

/**
 * Update a container
 * Change various configuration options of a container without having to
 * recreate it.
 *
 */
export const containerUpdate = <ThrowOnError extends boolean = false>(options: Options<ContainerUpdateData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<ContainerUpdateResponses, ContainerUpdateErrors, ThrowOnError>({
        responseType: 'json',
        url: '/containers/{id}/update',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Rename a container
 */
export const containerRename = <ThrowOnError extends boolean = false>(options: Options<ContainerRenameData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<ContainerRenameResponses, ContainerRenameErrors, ThrowOnError>({
        responseType: 'json',
        url: '/containers/{id}/rename',
        ...options
    });
};

/**
 * Pause a container
 * Use the freezer cgroup to suspend all processes in a container.
 *
 * Traditionally, when suspending a process the `SIGSTOP` signal is used,
 * which is observable by the process being suspended. With the freezer
 * cgroup the process is unaware, and unable to capture, that it is being
 * suspended, and subsequently resumed.
 *
 */
export const containerPause = <ThrowOnError extends boolean = false>(options: Options<ContainerPauseData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<ContainerPauseResponses, ContainerPauseErrors, ThrowOnError>({
        responseType: 'json',
        url: '/containers/{id}/pause',
        ...options
    });
};

/**
 * Unpause a container
 * Resume a container which has been paused.
 */
export const containerUnpause = <ThrowOnError extends boolean = false>(options: Options<ContainerUnpauseData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<ContainerUnpauseResponses, ContainerUnpauseErrors, ThrowOnError>({
        responseType: 'json',
        url: '/containers/{id}/unpause',
        ...options
    });
};

/**
 * Attach to a container
 * Attach to a container to read its output or send it input. You can attach
 * to the same container multiple times and you can reattach to containers
 * that have been detached.
 *
 * Either the `stream` or `logs` parameter must be `true` for this endpoint
 * to do anything.
 *
 * See the [documentation for the `docker attach` command](https://docs.docker.com/engine/reference/commandline/attach/)
 * for more details.
 *
 * ### Hijacking
 *
 * This endpoint hijacks the HTTP connection to transport `stdin`, `stdout`,
 * and `stderr` on the same socket.
 *
 * This is the response from the daemon for an attach request:
 *
 * ```
 * HTTP/1.1 200 OK
 * Content-Type: application/vnd.docker.raw-stream
 *
 * [STREAM]
 * ```
 *
 * After the headers and two new lines, the TCP connection can now be used
 * for raw, bidirectional communication between the client and server.
 *
 * To hint potential proxies about connection hijacking, the Docker client
 * can also optionally send connection upgrade headers.
 *
 * For example, the client sends this request to upgrade the connection:
 *
 * ```
 * POST /containers/16253994b7c4/attach?stream=1&stdout=1 HTTP/1.1
 * Upgrade: tcp
 * Connection: Upgrade
 * ```
 *
 * The Docker daemon will respond with a `101 UPGRADED` response, and will
 * similarly follow with the raw stream:
 *
 * ```
 * HTTP/1.1 101 UPGRADED
 * Content-Type: application/vnd.docker.raw-stream
 * Connection: Upgrade
 * Upgrade: tcp
 *
 * [STREAM]
 * ```
 *
 * ### Stream format
 *
 * When the TTY setting is disabled in [`POST /containers/create`](#operation/ContainerCreate),
 * the HTTP Content-Type header is set to application/vnd.docker.multiplexed-stream
 * and the stream over the hijacked connected is multiplexed to separate out
 * `stdout` and `stderr`. The stream consists of a series of frames, each
 * containing a header and a payload.
 *
 * The header contains the information which the stream writes (`stdout` or
 * `stderr`). It also contains the size of the associated frame encoded in
 * the last four bytes (`uint32`).
 *
 * It is encoded on the first eight bytes like this:
 *
 * ```go
 * header := [8]byte{STREAM_TYPE, 0, 0, 0, SIZE1, SIZE2, SIZE3, SIZE4}
 * ```
 *
 * `STREAM_TYPE` can be:
 *
 * - 0: `stdin` (is written on `stdout`)
 * - 1: `stdout`
 * - 2: `stderr`
 *
 * `SIZE1, SIZE2, SIZE3, SIZE4` are the four bytes of the `uint32` size
 * encoded as big endian.
 *
 * Following the header is the payload, which is the specified number of
 * bytes of `STREAM_TYPE`.
 *
 * The simplest way to implement this protocol is the following:
 *
 * 1. Read 8 bytes.
 * 2. Choose `stdout` or `stderr` depending on the first byte.
 * 3. Extract the frame size from the last four bytes.
 * 4. Read the extracted size and output it on the correct output.
 * 5. Goto 1.
 *
 * ### Stream format when using a TTY
 *
 * When the TTY setting is enabled in [`POST /containers/create`](#operation/ContainerCreate),
 * the stream is not multiplexed. The data exchanged over the hijacked
 * connection is simply the raw data from the process PTY and client's
 * `stdin`.
 *
 */
export const containerAttach = <ThrowOnError extends boolean = false>(options: Options<ContainerAttachData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<ContainerAttachResponses, ContainerAttachErrors, ThrowOnError>({
        responseType: 'blob',
        url: '/containers/{id}/attach',
        ...options
    });
};

/**
 * Attach to a container via a websocket
 */
export const containerAttachWebsocket = <ThrowOnError extends boolean = false>(options: Options<ContainerAttachWebsocketData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<ContainerAttachWebsocketResponses, ContainerAttachWebsocketErrors, ThrowOnError>({
        responseType: 'json',
        url: '/containers/{id}/attach/ws',
        ...options
    });
};

/**
 * Wait for a container
 * Block until a container stops, then returns the exit code.
 */
export const containerWait = <ThrowOnError extends boolean = false>(options: Options<ContainerWaitData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<ContainerWaitResponses, ContainerWaitErrors, ThrowOnError>({
        responseType: 'json',
        url: '/containers/{id}/wait',
        ...options
    });
};

/**
 * Remove a container
 */
export const containerDelete = <ThrowOnError extends boolean = false>(options: Options<ContainerDeleteData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).delete<ContainerDeleteResponses, ContainerDeleteErrors, ThrowOnError>({
        responseType: 'json',
        url: '/containers/{id}',
        ...options
    });
};

/**
 * Get an archive of a filesystem resource in a container
 * Get a tar archive of a resource in the filesystem of container id.
 */
export const containerArchive = <ThrowOnError extends boolean = false>(options: Options<ContainerArchiveData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<ContainerArchiveResponses, ContainerArchiveErrors, ThrowOnError>({
        responseType: 'blob',
        url: '/containers/{id}/archive',
        ...options
    });
};

/**
 * Get information about files in a container
 * A response header `X-Docker-Container-Path-Stat` is returned, containing
 * a base64 - encoded JSON object with some filesystem header information
 * about the path.
 *
 */
export const containerArchiveInfo = <ThrowOnError extends boolean = false>(options: Options<ContainerArchiveInfoData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).head<ContainerArchiveInfoResponses, ContainerArchiveInfoErrors, ThrowOnError>({
        responseType: 'json',
        url: '/containers/{id}/archive',
        ...options
    });
};

/**
 * Extract an archive of files or folders to a directory in a container
 * Upload a tar archive to be extracted to a path in the filesystem of container id.
 * `path` parameter is asserted to be a directory. If it exists as a file, 400 error
 * will be returned with message "not a directory".
 *
 */
export const putContainerArchive = <ThrowOnError extends boolean = false>(options: Options<PutContainerArchiveData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).put<PutContainerArchiveResponses, PutContainerArchiveErrors, ThrowOnError>({
        responseType: 'json',
        url: '/containers/{id}/archive',
        ...options,
        headers: {
            'Content-Type': 'application/x-tar',
            ...options.headers
        }
    });
};

/**
 * Delete stopped containers
 */
export const containerPrune = <ThrowOnError extends boolean = false>(options?: Options<ContainerPruneData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).post<ContainerPruneResponses, ContainerPruneErrors, ThrowOnError>({
        responseType: 'json',
        url: '/containers/prune',
        ...options
    });
};

/**
 * List Images
 * Returns a list of images on the server. Note that it uses a different, smaller representation of an image than inspecting a single image.
 */
export const imageList = <ThrowOnError extends boolean = false>(options?: Options<ImageListData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<ImageListResponses, ImageListErrors, ThrowOnError>({
        responseType: 'json',
        url: '/images/json',
        ...options
    });
};

/**
 * Build an image
 * Build an image from a tar archive with a `Dockerfile` in it.
 *
 * The `Dockerfile` specifies how the image is built from the tar archive. It is typically in the archive's root, but can be at a different path or have a different name by specifying the `dockerfile` parameter. [See the `Dockerfile` reference for more information](https://docs.docker.com/engine/reference/builder/).
 *
 * The Docker daemon performs a preliminary validation of the `Dockerfile` before starting the build, and returns an error if the syntax is incorrect. After that, each instruction is run one-by-one until the ID of the new image is output.
 *
 * The build is canceled if the client drops the connection by quitting or being killed.
 *
 */
export const imageBuild = <ThrowOnError extends boolean = false>(options?: Options<ImageBuildData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).post<ImageBuildResponses, ImageBuildErrors, ThrowOnError>({
        bodySerializer: null,
        responseType: 'json',
        url: '/build',
        ...options,
        headers: {
            'Content-type': 'application/octet-stream',
            ...options?.headers
        }
    });
};

/**
 * Delete builder cache
 */
export const buildPrune = <ThrowOnError extends boolean = false>(options?: Options<BuildPruneData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).post<BuildPruneResponses, BuildPruneErrors, ThrowOnError>({
        responseType: 'json',
        url: '/build/prune',
        ...options
    });
};

/**
 * Create an image
 * Pull or import an image.
 */
export const imageCreate = <ThrowOnError extends boolean = false>(options?: Options<ImageCreateData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).post<ImageCreateResponses, ImageCreateErrors, ThrowOnError>({
        bodySerializer: null,
        querySerializer: {
            array: {
                explode: false,
                style: 'form'
            }
        },
        responseType: 'json',
        url: '/images/create',
        ...options,
        headers: {
            'Content-Type': 'text/plain',
            ...options?.headers
        }
    });
};

/**
 * Inspect an image
 * Return low-level information about an image.
 */
export const imageInspect = <ThrowOnError extends boolean = false>(options: Options<ImageInspectData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<ImageInspectResponses, ImageInspectErrors, ThrowOnError>({
        responseType: 'json',
        url: '/images/{name}/json',
        ...options
    });
};

/**
 * Get the history of an image
 * Return parent layers of an image.
 */
export const imageHistory = <ThrowOnError extends boolean = false>(options: Options<ImageHistoryData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<ImageHistoryResponses, ImageHistoryErrors, ThrowOnError>({
        responseType: 'json',
        url: '/images/{name}/history',
        ...options
    });
};

/**
 * Push an image
 * Push an image to a registry.
 *
 * If you wish to push an image on to a private registry, that image must
 * already have a tag which references the registry. For example,
 * `registry.example.com/myimage:latest`.
 *
 * The push is cancelled if the HTTP connection is closed.
 *
 */
export const imagePush = <ThrowOnError extends boolean = false>(options: Options<ImagePushData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<ImagePushResponses, ImagePushErrors, ThrowOnError>({
        responseType: 'json',
        url: '/images/{name}/push',
        ...options
    });
};

/**
 * Tag an image
 * Tag an image so that it becomes part of a repository.
 */
export const imageTag = <ThrowOnError extends boolean = false>(options: Options<ImageTagData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<ImageTagResponses, ImageTagErrors, ThrowOnError>({
        responseType: 'json',
        url: '/images/{name}/tag',
        ...options
    });
};

/**
 * Remove an image
 * Remove an image, along with any untagged parent images that were
 * referenced by that image.
 *
 * Images can't be removed if they have descendant images, are being
 * used by a running container or are being used by a build.
 *
 */
export const imageDelete = <ThrowOnError extends boolean = false>(options: Options<ImageDeleteData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).delete<ImageDeleteResponses, ImageDeleteErrors, ThrowOnError>({
        querySerializer: {
            array: {
                explode: false,
                style: 'form'
            }
        },
        responseType: 'json',
        url: '/images/{name}',
        ...options
    });
};

/**
 * Search images
 * Search for an image on Docker Hub.
 */
export const imageSearch = <ThrowOnError extends boolean = false>(options: Options<ImageSearchData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<ImageSearchResponses, ImageSearchErrors, ThrowOnError>({
        responseType: 'json',
        url: '/images/search',
        ...options
    });
};

/**
 * Delete unused images
 */
export const imagePrune = <ThrowOnError extends boolean = false>(options?: Options<ImagePruneData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).post<ImagePruneResponses, ImagePruneErrors, ThrowOnError>({
        responseType: 'json',
        url: '/images/prune',
        ...options
    });
};

/**
 * Check auth configuration
 * Validate credentials for a registry and, if available, get an identity
 * token for accessing the registry without password.
 *
 */
export const systemAuth = <ThrowOnError extends boolean = false>(options?: Options<SystemAuthData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).post<SystemAuthResponses, SystemAuthErrors, ThrowOnError>({
        responseType: 'json',
        url: '/auth',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Get system information
 */
export const systemInfo = <ThrowOnError extends boolean = false>(options?: Options<SystemInfoData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<SystemInfoResponses, SystemInfoErrors, ThrowOnError>({
        responseType: 'json',
        url: '/info',
        ...options
    });
};

/**
 * Get version
 * Returns the version of Docker that is running and various information about the system that Docker is running on.
 */
export const systemVersion = <ThrowOnError extends boolean = false>(options?: Options<SystemVersionData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<SystemVersionResponses, SystemVersionErrors, ThrowOnError>({
        responseType: 'json',
        url: '/version',
        ...options
    });
};

/**
 * Ping
 * This is a dummy endpoint you can use to test if the server is accessible.
 */
export const systemPing = <ThrowOnError extends boolean = false>(options?: Options<SystemPingData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<SystemPingResponses, SystemPingErrors, ThrowOnError>({
        responseType: 'text',
        url: '/_ping',
        ...options
    });
};

/**
 * Ping
 * This is a dummy endpoint you can use to test if the server is accessible.
 */
export const systemPingHead = <ThrowOnError extends boolean = false>(options?: Options<SystemPingHeadData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).head<SystemPingHeadResponses, SystemPingHeadErrors, ThrowOnError>({
        responseType: 'text',
        url: '/_ping',
        ...options
    });
};

/**
 * Create a new image from a container
 */
export const imageCommit = <ThrowOnError extends boolean = false>(options?: Options<ImageCommitData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).post<ImageCommitResponses, ImageCommitErrors, ThrowOnError>({
        responseType: 'json',
        url: '/commit',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Monitor events
 * Stream real-time events from the server.
 *
 * Various objects within Docker report events when something happens to them.
 *
 * Containers report these events: `attach`, `commit`, `copy`, `create`, `destroy`, `detach`, `die`, `exec_create`, `exec_detach`, `exec_start`, `exec_die`, `export`, `health_status`, `kill`, `oom`, `pause`, `rename`, `resize`, `restart`, `start`, `stop`, `top`, `unpause`, `update`, and `prune`
 *
 * Images report these events: `create`, `delete`, `import`, `load`, `pull`, `push`, `save`, `tag`, `untag`, and `prune`
 *
 * Volumes report these events: `create`, `mount`, `unmount`, `destroy`, and `prune`
 *
 * Networks report these events: `create`, `connect`, `disconnect`, `destroy`, `update`, `remove`, and `prune`
 *
 * The Docker daemon reports these events: `reload`
 *
 * Services report these events: `create`, `update`, and `remove`
 *
 * Nodes report these events: `create`, `update`, and `remove`
 *
 * Secrets report these events: `create`, `update`, and `remove`
 *
 * Configs report these events: `create`, `update`, and `remove`
 *
 * The Builder reports `prune` events
 *
 */
export const systemEvents = <ThrowOnError extends boolean = false>(options?: Options<SystemEventsData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<SystemEventsResponses, SystemEventsErrors, ThrowOnError>({
        responseType: 'json',
        url: '/events',
        ...options
    });
};

/**
 * Get data usage information
 */
export const systemDataUsage = <ThrowOnError extends boolean = false>(options?: Options<SystemDataUsageData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<SystemDataUsageResponses, SystemDataUsageErrors, ThrowOnError>({
        responseType: 'json',
        url: '/system/df',
        ...options
    });
};

/**
 * Export an image
 * Get a tarball containing all images and metadata for a repository.
 *
 * If `name` is a specific name and tag (e.g. `ubuntu:latest`), then only that image (and its parents) are returned. If `name` is an image ID, similarly only that image (and its parents) are returned, but with the exclusion of the `repositories` file in the tarball, as there were no image names referenced.
 *
 * ### Image tarball format
 *
 * An image tarball contains [Content as defined in the OCI Image Layout Specification](https://github.com/opencontainers/image-spec/blob/v1.1.1/image-layout.md#content).
 *
 * Additionally, includes the manifest.json file associated with a backwards compatible docker save format.
 *
 * If the tarball defines a repository, the tarball should also include a `repositories` file at the root that contains a list of repository and tag names mapped to layer IDs.
 *
 * ```json
 * {
 * "hello-world": {
 * "latest": "565a9d68a73f6706862bfe8409a7f659776d4d60a8d096eb4a3cbce6999cc2a1"
 * }
 * }
 * ```
 *
 */
export const imageGet = <ThrowOnError extends boolean = false>(options: Options<ImageGetData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<ImageGetResponses, ImageGetErrors, ThrowOnError>({
        responseType: 'blob',
        url: '/images/{name}/get',
        ...options
    });
};

/**
 * Export several images
 * Get a tarball containing all images and metadata for several image
 * repositories.
 *
 * For each value of the `names` parameter: if it is a specific name and
 * tag (e.g. `ubuntu:latest`), then only that image (and its parents) are
 * returned; if it is an image ID, similarly only that image (and its parents)
 * are returned and there would be no names referenced in the 'repositories'
 * file for this image ID.
 *
 * For details on the format, see the [export image endpoint](#operation/ImageGet).
 *
 */
export const imageGetAll = <ThrowOnError extends boolean = false>(options?: Options<ImageGetAllData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<ImageGetAllResponses, ImageGetAllErrors, ThrowOnError>({
        querySerializer: {
            array: {
                explode: false,
                style: 'form'
            }
        },
        responseType: 'blob',
        url: '/images/get',
        ...options
    });
};

/**
 * Import images
 * Load a set of images and tags into a repository.
 *
 * For details on the format, see the [export image endpoint](#operation/ImageGet).
 *
 */
export const imageLoad = <ThrowOnError extends boolean = false>(options?: Options<ImageLoadData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).post<ImageLoadResponses, ImageLoadErrors, ThrowOnError>({
        responseType: 'json',
        url: '/images/load',
        ...options,
        headers: {
            'Content-Type': 'application/x-tar',
            ...options?.headers
        }
    });
};

/**
 * Create an exec instance
 * Run a command inside a running container.
 */
export const containerExec = <ThrowOnError extends boolean = false>(options: Options<ContainerExecData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<ContainerExecResponses, ContainerExecErrors, ThrowOnError>({
        responseType: 'json',
        url: '/containers/{id}/exec',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Start an exec instance
 * Starts a previously set up exec instance. If detach is true, this endpoint
 * returns immediately after starting the command. Otherwise, it sets up an
 * interactive session with the command.
 *
 */
export const execStart = <ThrowOnError extends boolean = false>(options: Options<ExecStartData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<ExecStartResponses, ExecStartErrors, ThrowOnError>({
        responseType: 'blob',
        url: '/exec/{id}/start',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Resize an exec instance
 * Resize the TTY session used by an exec instance. This endpoint only works
 * if `tty` was specified as part of creating and starting the exec instance.
 *
 */
export const execResize = <ThrowOnError extends boolean = false>(options: Options<ExecResizeData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<ExecResizeResponses, ExecResizeErrors, ThrowOnError>({
        responseType: 'json',
        url: '/exec/{id}/resize',
        ...options
    });
};

/**
 * Inspect an exec instance
 * Return low-level information about an exec instance.
 */
export const execInspect = <ThrowOnError extends boolean = false>(options: Options<ExecInspectData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<ExecInspectResponses, ExecInspectErrors, ThrowOnError>({
        responseType: 'json',
        url: '/exec/{id}/json',
        ...options
    });
};

/**
 * List volumes
 */
export const volumeList = <ThrowOnError extends boolean = false>(options?: Options<VolumeListData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<VolumeListResponses, VolumeListErrors, ThrowOnError>({
        responseType: 'json',
        url: '/volumes',
        ...options
    });
};

/**
 * Create a volume
 */
export const volumeCreate = <ThrowOnError extends boolean = false>(options: Options<VolumeCreateData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<VolumeCreateResponses, VolumeCreateErrors, ThrowOnError>({
        responseType: 'json',
        url: '/volumes/create',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Remove a volume
 * Instruct the driver to remove the volume.
 */
export const volumeDelete = <ThrowOnError extends boolean = false>(options: Options<VolumeDeleteData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).delete<VolumeDeleteResponses, VolumeDeleteErrors, ThrowOnError>({
        responseType: 'json',
        url: '/volumes/{name}',
        ...options
    });
};

/**
 * Inspect a volume
 */
export const volumeInspect = <ThrowOnError extends boolean = false>(options: Options<VolumeInspectData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<VolumeInspectResponses, VolumeInspectErrors, ThrowOnError>({
        responseType: 'json',
        url: '/volumes/{name}',
        ...options
    });
};

/**
 * "Update a volume. Valid only for Swarm cluster volumes"
 *
 */
export const volumeUpdate = <ThrowOnError extends boolean = false>(options: Options<VolumeUpdateData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).put<VolumeUpdateResponses, VolumeUpdateErrors, ThrowOnError>({
        responseType: 'json',
        url: '/volumes/{name}',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Delete unused volumes
 */
export const volumePrune = <ThrowOnError extends boolean = false>(options?: Options<VolumePruneData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).post<VolumePruneResponses, VolumePruneErrors, ThrowOnError>({
        responseType: 'json',
        url: '/volumes/prune',
        ...options
    });
};

/**
 * List networks
 * Returns a list of networks. For details on the format, see the
 * [network inspect endpoint](#operation/NetworkInspect).
 *
 * Note that it uses a different, smaller representation of a network than
 * inspecting a single network. For example, the list of containers attached
 * to the network is not propagated in API versions 1.28 and up.
 *
 */
export const networkList = <ThrowOnError extends boolean = false>(options?: Options<NetworkListData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<NetworkListResponses, NetworkListErrors, ThrowOnError>({
        responseType: 'json',
        url: '/networks',
        ...options
    });
};

/**
 * Remove a network
 */
export const networkDelete = <ThrowOnError extends boolean = false>(options: Options<NetworkDeleteData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).delete<NetworkDeleteResponses, NetworkDeleteErrors, ThrowOnError>({
        responseType: 'json',
        url: '/networks/{id}',
        ...options
    });
};

/**
 * Inspect a network
 */
export const networkInspect = <ThrowOnError extends boolean = false>(options: Options<NetworkInspectData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<NetworkInspectResponses, NetworkInspectErrors, ThrowOnError>({
        responseType: 'json',
        url: '/networks/{id}',
        ...options
    });
};

/**
 * Create a network
 */
export const networkCreate = <ThrowOnError extends boolean = false>(options: Options<NetworkCreateData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<NetworkCreateResponses, NetworkCreateErrors, ThrowOnError>({
        responseType: 'json',
        url: '/networks/create',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Connect a container to a network
 * The network must be either a local-scoped network or a swarm-scoped network with the `attachable` option set. A network cannot be re-attached to a running container
 */
export const networkConnect = <ThrowOnError extends boolean = false>(options: Options<NetworkConnectData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<NetworkConnectResponses, NetworkConnectErrors, ThrowOnError>({
        responseType: 'json',
        url: '/networks/{id}/connect',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Disconnect a container from a network
 */
export const networkDisconnect = <ThrowOnError extends boolean = false>(options: Options<NetworkDisconnectData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<NetworkDisconnectResponses, NetworkDisconnectErrors, ThrowOnError>({
        responseType: 'json',
        url: '/networks/{id}/disconnect',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Delete unused networks
 */
export const networkPrune = <ThrowOnError extends boolean = false>(options?: Options<NetworkPruneData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).post<NetworkPruneResponses, NetworkPruneErrors, ThrowOnError>({
        responseType: 'json',
        url: '/networks/prune',
        ...options
    });
};

/**
 * List plugins
 * Returns information about installed plugins.
 */
export const pluginList = <ThrowOnError extends boolean = false>(options?: Options<PluginListData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<PluginListResponses, PluginListErrors, ThrowOnError>({
        responseType: 'json',
        url: '/plugins',
        ...options
    });
};

/**
 * Get plugin privileges
 */
export const getPluginPrivileges = <ThrowOnError extends boolean = false>(options: Options<GetPluginPrivilegesData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<GetPluginPrivilegesResponses, GetPluginPrivilegesErrors, ThrowOnError>({
        responseType: 'json',
        url: '/plugins/privileges',
        ...options
    });
};

/**
 * Install a plugin
 * Pulls and installs a plugin. After the plugin is installed, it can be
 * enabled using the [`POST /plugins/{name}/enable` endpoint](#operation/PostPluginsEnable).
 *
 */
export const pluginPull = <ThrowOnError extends boolean = false>(options: Options<PluginPullData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<PluginPullResponses, PluginPullErrors, ThrowOnError>({
        responseType: 'json',
        url: '/plugins/pull',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Inspect a plugin
 */
export const pluginInspect = <ThrowOnError extends boolean = false>(options: Options<PluginInspectData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<PluginInspectResponses, PluginInspectErrors, ThrowOnError>({
        responseType: 'json',
        url: '/plugins/{name}/json',
        ...options
    });
};

/**
 * Remove a plugin
 */
export const pluginDelete = <ThrowOnError extends boolean = false>(options: Options<PluginDeleteData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).delete<PluginDeleteResponses, PluginDeleteErrors, ThrowOnError>({
        responseType: 'json',
        url: '/plugins/{name}',
        ...options
    });
};

/**
 * Enable a plugin
 */
export const pluginEnable = <ThrowOnError extends boolean = false>(options: Options<PluginEnableData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<PluginEnableResponses, PluginEnableErrors, ThrowOnError>({
        responseType: 'json',
        url: '/plugins/{name}/enable',
        ...options
    });
};

/**
 * Disable a plugin
 */
export const pluginDisable = <ThrowOnError extends boolean = false>(options: Options<PluginDisableData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<PluginDisableResponses, PluginDisableErrors, ThrowOnError>({
        responseType: 'json',
        url: '/plugins/{name}/disable',
        ...options
    });
};

/**
 * Upgrade a plugin
 */
export const pluginUpgrade = <ThrowOnError extends boolean = false>(options: Options<PluginUpgradeData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<PluginUpgradeResponses, PluginUpgradeErrors, ThrowOnError>({
        responseType: 'json',
        url: '/plugins/{name}/upgrade',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Create a plugin
 */
export const pluginCreate = <ThrowOnError extends boolean = false>(options: Options<PluginCreateData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<PluginCreateResponses, PluginCreateErrors, ThrowOnError>({
        responseType: 'json',
        url: '/plugins/create',
        ...options,
        headers: {
            'Content-Type': 'application/x-tar',
            ...options.headers
        }
    });
};

/**
 * Push a plugin
 * Push a plugin to the registry.
 *
 */
export const pluginPush = <ThrowOnError extends boolean = false>(options: Options<PluginPushData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<PluginPushResponses, PluginPushErrors, ThrowOnError>({
        responseType: 'json',
        url: '/plugins/{name}/push',
        ...options
    });
};

/**
 * Configure a plugin
 */
export const pluginSet = <ThrowOnError extends boolean = false>(options: Options<PluginSetData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<PluginSetResponses, PluginSetErrors, ThrowOnError>({
        responseType: 'json',
        url: '/plugins/{name}/set',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * List nodes
 */
export const nodeList = <ThrowOnError extends boolean = false>(options?: Options<NodeListData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<NodeListResponses, NodeListErrors, ThrowOnError>({
        responseType: 'json',
        url: '/nodes',
        ...options
    });
};

/**
 * Delete a node
 */
export const nodeDelete = <ThrowOnError extends boolean = false>(options: Options<NodeDeleteData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).delete<NodeDeleteResponses, NodeDeleteErrors, ThrowOnError>({
        responseType: 'json',
        url: '/nodes/{id}',
        ...options
    });
};

/**
 * Inspect a node
 */
export const nodeInspect = <ThrowOnError extends boolean = false>(options: Options<NodeInspectData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<NodeInspectResponses, NodeInspectErrors, ThrowOnError>({
        responseType: 'json',
        url: '/nodes/{id}',
        ...options
    });
};

/**
 * Update a node
 */
export const nodeUpdate = <ThrowOnError extends boolean = false>(options: Options<NodeUpdateData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<NodeUpdateResponses, NodeUpdateErrors, ThrowOnError>({
        responseType: 'json',
        url: '/nodes/{id}/update',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Inspect swarm
 */
export const swarmInspect = <ThrowOnError extends boolean = false>(options?: Options<SwarmInspectData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<SwarmInspectResponses, SwarmInspectErrors, ThrowOnError>({
        responseType: 'json',
        url: '/swarm',
        ...options
    });
};

/**
 * Initialize a new swarm
 */
export const swarmInit = <ThrowOnError extends boolean = false>(options: Options<SwarmInitData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<SwarmInitResponses, SwarmInitErrors, ThrowOnError>({
        responseType: 'json',
        url: '/swarm/init',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Join an existing swarm
 */
export const swarmJoin = <ThrowOnError extends boolean = false>(options: Options<SwarmJoinData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<SwarmJoinResponses, SwarmJoinErrors, ThrowOnError>({
        responseType: 'json',
        url: '/swarm/join',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Leave a swarm
 */
export const swarmLeave = <ThrowOnError extends boolean = false>(options?: Options<SwarmLeaveData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).post<SwarmLeaveResponses, SwarmLeaveErrors, ThrowOnError>({
        responseType: 'json',
        url: '/swarm/leave',
        ...options
    });
};

/**
 * Update a swarm
 */
export const swarmUpdate = <ThrowOnError extends boolean = false>(options: Options<SwarmUpdateData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<SwarmUpdateResponses, SwarmUpdateErrors, ThrowOnError>({
        responseType: 'json',
        url: '/swarm/update',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Get the unlock key
 */
export const swarmUnlockkey = <ThrowOnError extends boolean = false>(options?: Options<SwarmUnlockkeyData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<SwarmUnlockkeyResponses, SwarmUnlockkeyErrors, ThrowOnError>({
        responseType: 'json',
        url: '/swarm/unlockkey',
        ...options
    });
};

/**
 * Unlock a locked manager
 */
export const swarmUnlock = <ThrowOnError extends boolean = false>(options: Options<SwarmUnlockData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<SwarmUnlockResponses, SwarmUnlockErrors, ThrowOnError>({
        responseType: 'json',
        url: '/swarm/unlock',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * List services
 */
export const serviceList = <ThrowOnError extends boolean = false>(options?: Options<ServiceListData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<ServiceListResponses, ServiceListErrors, ThrowOnError>({
        responseType: 'json',
        url: '/services',
        ...options
    });
};

/**
 * Create a service
 */
export const serviceCreate = <ThrowOnError extends boolean = false>(options: Options<ServiceCreateData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<ServiceCreateResponses, ServiceCreateErrors, ThrowOnError>({
        responseType: 'json',
        url: '/services/create',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Delete a service
 */
export const serviceDelete = <ThrowOnError extends boolean = false>(options: Options<ServiceDeleteData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).delete<ServiceDeleteResponses, ServiceDeleteErrors, ThrowOnError>({
        responseType: 'json',
        url: '/services/{id}',
        ...options
    });
};

/**
 * Inspect a service
 */
export const serviceInspect = <ThrowOnError extends boolean = false>(options: Options<ServiceInspectData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<ServiceInspectResponses, ServiceInspectErrors, ThrowOnError>({
        responseType: 'json',
        url: '/services/{id}',
        ...options
    });
};

/**
 * Update a service
 */
export const serviceUpdate = <ThrowOnError extends boolean = false>(options: Options<ServiceUpdateData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<ServiceUpdateResponses, ServiceUpdateErrors, ThrowOnError>({
        responseType: 'json',
        url: '/services/{id}/update',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Get service logs
 * Get `stdout` and `stderr` logs from a service. See also
 * [`/containers/{id}/logs`](#operation/ContainerLogs).
 *
 * **Note**: This endpoint works only for services with the `local`,
 * `json-file` or `journald` logging drivers.
 *
 */
export const serviceLogs = <ThrowOnError extends boolean = false>(options: Options<ServiceLogsData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<ServiceLogsResponses, ServiceLogsErrors, ThrowOnError>({
        responseType: 'blob',
        url: '/services/{id}/logs',
        ...options
    });
};

/**
 * List tasks
 */
export const taskList = <ThrowOnError extends boolean = false>(options?: Options<TaskListData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<TaskListResponses, TaskListErrors, ThrowOnError>({
        responseType: 'json',
        url: '/tasks',
        ...options
    });
};

/**
 * Inspect a task
 */
export const taskInspect = <ThrowOnError extends boolean = false>(options: Options<TaskInspectData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<TaskInspectResponses, TaskInspectErrors, ThrowOnError>({
        responseType: 'json',
        url: '/tasks/{id}',
        ...options
    });
};

/**
 * Get task logs
 * Get `stdout` and `stderr` logs from a task.
 * See also [`/containers/{id}/logs`](#operation/ContainerLogs).
 *
 * **Note**: This endpoint works only for services with the `local`,
 * `json-file` or `journald` logging drivers.
 *
 */
export const taskLogs = <ThrowOnError extends boolean = false>(options: Options<TaskLogsData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<TaskLogsResponses, TaskLogsErrors, ThrowOnError>({
        responseType: 'blob',
        url: '/tasks/{id}/logs',
        ...options
    });
};

/**
 * List secrets
 */
export const secretList = <ThrowOnError extends boolean = false>(options?: Options<SecretListData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<SecretListResponses, SecretListErrors, ThrowOnError>({
        responseType: 'json',
        url: '/secrets',
        ...options
    });
};

/**
 * Create a secret
 */
export const secretCreate = <ThrowOnError extends boolean = false>(options?: Options<SecretCreateData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).post<SecretCreateResponses, SecretCreateErrors, ThrowOnError>({
        responseType: 'json',
        url: '/secrets/create',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Delete a secret
 */
export const secretDelete = <ThrowOnError extends boolean = false>(options: Options<SecretDeleteData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).delete<SecretDeleteResponses, SecretDeleteErrors, ThrowOnError>({
        responseType: 'json',
        url: '/secrets/{id}',
        ...options
    });
};

/**
 * Inspect a secret
 */
export const secretInspect = <ThrowOnError extends boolean = false>(options: Options<SecretInspectData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<SecretInspectResponses, SecretInspectErrors, ThrowOnError>({
        responseType: 'json',
        url: '/secrets/{id}',
        ...options
    });
};

/**
 * Update a Secret
 */
export const secretUpdate = <ThrowOnError extends boolean = false>(options: Options<SecretUpdateData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<SecretUpdateResponses, SecretUpdateErrors, ThrowOnError>({
        responseType: 'json',
        url: '/secrets/{id}/update',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * List configs
 */
export const configList = <ThrowOnError extends boolean = false>(options?: Options<ConfigListData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<ConfigListResponses, ConfigListErrors, ThrowOnError>({
        responseType: 'json',
        url: '/configs',
        ...options
    });
};

/**
 * Create a config
 */
export const configCreate = <ThrowOnError extends boolean = false>(options?: Options<ConfigCreateData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).post<ConfigCreateResponses, ConfigCreateErrors, ThrowOnError>({
        responseType: 'json',
        url: '/configs/create',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Delete a config
 */
export const configDelete = <ThrowOnError extends boolean = false>(options: Options<ConfigDeleteData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).delete<ConfigDeleteResponses, ConfigDeleteErrors, ThrowOnError>({
        responseType: 'json',
        url: '/configs/{id}',
        ...options
    });
};

/**
 * Inspect a config
 */
export const configInspect = <ThrowOnError extends boolean = false>(options: Options<ConfigInspectData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<ConfigInspectResponses, ConfigInspectErrors, ThrowOnError>({
        responseType: 'json',
        url: '/configs/{id}',
        ...options
    });
};

/**
 * Update a Config
 */
export const configUpdate = <ThrowOnError extends boolean = false>(options: Options<ConfigUpdateData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<ConfigUpdateResponses, ConfigUpdateErrors, ThrowOnError>({
        responseType: 'json',
        url: '/configs/{id}/update',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Get image information from the registry
 * Return image digest and platform information by contacting the registry.
 *
 */
export const distributionInspect = <ThrowOnError extends boolean = false>(options: Options<DistributionInspectData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<DistributionInspectResponses, DistributionInspectErrors, ThrowOnError>({
        responseType: 'json',
        url: '/distribution/{name}/json',
        ...options
    });
};

/**
 * Initialize interactive session
 * Start a new interactive session with a server. Session allows server to
 * call back to the client for advanced capabilities.
 *
 * ### Hijacking
 *
 * This endpoint hijacks the HTTP connection to HTTP2 transport that allows
 * the client to expose gPRC services on that connection.
 *
 * For example, the client sends this request to upgrade the connection:
 *
 * ```
 * POST /session HTTP/1.1
 * Upgrade: h2c
 * Connection: Upgrade
 * ```
 *
 * The Docker daemon responds with a `101 UPGRADED` response follow with
 * the raw stream:
 *
 * ```
 * HTTP/1.1 101 UPGRADED
 * Connection: Upgrade
 * Upgrade: h2c
 * ```
 *
 */
export const session = <ThrowOnError extends boolean = false>(options?: Options<SessionData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).post<unknown, SessionErrors, ThrowOnError>({
        url: '/session',
        ...options
    });
};